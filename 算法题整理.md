## 所有

#### 题目1

给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个： 

区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列  [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值

  **思路**： 对每个i数，以该数为中心，分别项左向由两边探测直到遇到比该数还小的数停止，探测过程累加探测到的数，探测结束累加得到的和乘该数得到该区间的最大值，依次遍历数组的每个数，得到最大值。

#### 题目2

产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。

同时有M个程序员，每个程序员空闲的时候就会查看每个PM尚未执行并且最想完成的一个idea,然后从中挑选出所需时间最小的一个idea独立实现，如果所需时间相同则选择PM序号最小的。直到完成了idea才会重复上述操作。如果有多个同时处于空闲状态的程序员，那么他们会依次进行查看idea的操作。

求每个idea实现的时间。

输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。输出P行，分别表示每个idea实现的时间点。

**思路**： 分几种情况，idea执行中，待执行的idea队列，执行完的队列，每次随着time+1，要观察执行队列中的idea是否到时间了，以及已经到时间的Idea开始加入待执行队列，若有空闲程序员，则选择待执行队列的Idea，选择条件就是根据题目所说，先选择优先级高的，在选择时间少的，在选择最早想出的，会有多个满足的话，继续选择PM序号小的，这样就能从待执行队列选择出一个idea，这样可用程序员-1，直到idea全部执行完了，确保执行队列为空而且可执行的idea数量为空，（执行队列可能idea都分出去了但还没执行完）

**3. 大数相乘**   

> 输入的两个大数字符串， 首先变列表，每个都是Int，并逆序，创建一个新的数组，存放结果，两个循环，i,j，A[i] *  A[j] 存进 C[i+j]里，如果这个 数值大于10，则i+j+1应该存放十位数，原先的存放个数，每个都这样，最后得到的数组是结果的逆序，但要记得初始化的长度不是最终长度而是最大长度，所以要去掉C数组的后面的0，因为一个数的开头页不可能是0 

**4. KMP，匹配字符串**，返回匹配的第一个下标位置

> 用 kmp算法，O(N)，遇到失配，j就变为next数组对应的值继续匹配，知道j超过了目标长度，说明匹配成功
>
> 具体的next数组的生成，是对target求的，有k,j= -1，0， k是代表已经有几个数是匹配上的，j就是遍历到第几个数了，每次到j是去看j之前的最大长度不包括j

**5. 中心扩展算法，最长回文子串**

> 对S遍历，每个i都要判断以i为中心向两边扩展的长度和以i,i+1为中心向两边扩展的长度。因为长度有奇偶性。扩展就是左右两边同时扩展，满足不越界且左右扩展相等