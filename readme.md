题库

> **递归**
* simple Number Finding: 一个数能用2，3，5这三个数相乘得到数叫做amazing number。

  题解：输入一个数，能被2整除多少次a，能被3整除多少次b，能被5整除多少次c，check这些次数2^a×3^b×5^c = input，如果成立说明是amazing number，不成立就不是。

  例子：8（2，2，2） 14（none）1230187500 (2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5,5） 

> **动态规划**
  [动态规划问题](https://www.zhihu.com/question/23995189)：**最优子结构+无后效性**。求解方式有自顶向下的备忘录法和自底向上
  能运用动态规划的问题应满足：最优子结构和重复子问题，在动态规划中使用数组来保存子问题的
  解。动态问题的本质是对问题状态的定义和状态转移方程的定义。记忆化的求解递推式。
  * 每个阶段只有一个状态-> 递推
  * 每个阶段的最优状态都是由上一个阶段的最优状态得到 -> 贪心
  * 每个阶段的最优状态是由之前所有阶段的状态组合得到 -> 搜索
  * 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到 -> 动态规划
* 求最大子序列：<pre><code>  for i in range(1, len(arr)):
        if maxhere <= 0:
            maxhere = arr[i]
        else:
            maxhere += arr[i]
     </pre></code>
> **排序问题**
* shell排序：shell排序根据定义的间隔进行排序，注意的是，不是对两个差为gap的一对进行比较，如当前有6个数的数组，index为2，下标为0，2，4进行排序，下标为1，3，5进行排序。
* 拓扑排序：针对有向无环图，展开有两种，一种求图是否有环，一种求拓扑排序的解的个数。
  对于前者，存储图的边信息，遍历每个顶点，用字典存储计算每个顶点的入度，为0进队列。以队列是否为空作为循环条件，出队列一个，判断以该元素起点的相邻点入度减一
  及时判断顶点入度是否为0时，则入队，直到队列为空退出。可以把每次出队的记录即为拓扑顺序，最后判断该记录是否包括了所有点，没有则
  说明有环。 对于后者，用深搜判断递归，用邻接矩阵存储，循环条件为点的个数，每次调用函数递归一次加一表示深度加1，要判断该点是否被访问过，且满足入度为0返回。

> **树**

+ KD树：[博客](http://www.cnblogs.com/lysuns/articles/4710712.html) 正常情况建树