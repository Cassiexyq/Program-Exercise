#### 1.	最大滑动窗口

给出一个可能包含重复的整数数组，和一个大小为 *k* 的滑动窗口, 从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值。

**思路**：双端队列，首先选出第一个k的最大值留在队列，接下来枚移动1个位置，数组从k下标开始，如果Num[i] 比队列尾头大的话，一直弹出队尾直到为空了或者比num[i]大了，然后队尾插入这个数（就是说队列里的数一定事要比要即将加进去的数都大的），同时还要注意如果队列里有比k多的数，越界了，要弹出队首，直到所有遍历完。

#### 2.	二维区域和检索

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (*row*1, *col*1) ，右下角为 (*row*2, *col*2)。

**思路**：累积和是根据索引 0 处的原点计算。也就是说先把这个矩阵每个到原点的面积都计算出来，存入一个数组，然后每次查询只要通过已知的这些面积去计算要求的面积就行。查询O(1)  空间O(mn)。预计算方式是，对每个点来说，存储dp是从1开始计数，

这个点的上面一个点到原点面积+左边点到原点面积- 斜对角方向的上一个点的面积+这个点的数

$dp[r][c] = dp[r-1][c] + dp[r][c-1] - dp[r-1][c-1] + arr[r-1][c-1]​$

得到要求的面积是右下角到原点的总面积 - 右上角到原点的面积 - 左下角到原点的面积 + 左上角到原点的面积

$dp[row2+1][col2+1] - dp[row1][col2+1] - dp[row2+1][col1] + dp[row1][col1]$

注意的是：左上角是已经在这面积内的了是一整块pixel想象一下~，所以上面的+1 -1要清楚

#### 3.	计算平方根

**思路**：从泰勒展开入手，作用求方程解（sqrt），或求函数极值（ML update）

牛顿法：$f(x) = f(x_0)+ f'(x_0)(x-x_0)$

binary search法，快排，low< high，当满足 mid*mid<x是，如果(mid+1)的平方>x，则返回，不然说明这个值应该在mid右边，否则在mid左边，不断循环。

#### 4.	幂运算

方法一：首先指数若负基数取倒指数取正，判断奇数偶数，不断除2，若偶数基数做 x*x操作，若奇数另乘x

```c++
return !(n & 1)? myPow(x*x, n/2): x * myPow(x*x, n/2);
```

方法二：位运算，

```c++
      int res = 1;
        int tmp = x;
        while(n){
            if(n & 1) res *= tmp;
            tmp *= tmp;
            n >> 1;
        }
        return res;
```

#### 5. 接雨水

 O(n)， 双指针思想 

#### 6. 旋转数组的最小值

 二分查找，变化一下条件





